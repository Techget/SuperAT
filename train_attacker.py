import torch
import torch.nn as nn
import torchvision
from torchvision.utils import make_grid
import torchvision.transforms as transforms
import numpy as np
import matplotlib.pyplot as plt
import torch
from torch.autograd import Variable
from dataloader import dataloader
import utils
import torchvision.models as models
import os
from pytorch_lightning.utilities.seed import seed_everything
from lightning_VAE import VAE
from torch.utils.tensorboard import SummaryWriter
from discriminator import DiscriminatorRes

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
torch.autograd.set_detect_anomaly(True)


# hyper parameter
# convert to use arg parser
epochs=100
lr_attacker=3e-4
batch_size = 32
kld_weight = 0.1 # for VAE (Used in standarattack_defensor_loss_weight libraries)
attack_defensor_loss_weight = 0.1 # for the loss of defensor with input generated by generator
                          # to make sure these errors are in the same numeric level


# logging and saving result
checkpoint_dir='./superAT_attacker_checkpoints/'
writer = SummaryWriter()


# For reproducibility
seed_everything(7, True)

data_loader=dataloader(batch_size)

# load pretrained VAE
attacker=VAE(input_height=32,
    kl_coeff=kld_weight).from_pretrained('cifar10-resnet18')
attacker=attacker.to(device)

# load pretrained resnet 18
# defensor = models.resnet18(pretrained=True).eval()
defensor=DiscriminatorRes().to(device)
state_dict = os.path.join(
  "state_dicts", "resnet18" + ".pt"
)
defensor.load_state_dict(torch.load(state_dict))

criterion = nn.CrossEntropyLoss().to(device)
optim_gen=torch.optim.RMSprop(attacker.parameters(), lr=lr_attacker)
# optim_Dis=torch.optim.RMSprop(discrim.parameters(), lr=lr_dis)

example_input_images, _ = next(iter(data_loader))
grid = torchvision.utils.make_grid(example_input_images)
writer.add_image("images", grid)
writer.add_graph(attacker, example_input_images.to(device))

def main():

    for epoch in range(epochs):
        total_vae_loss = 0
        total_attacker_output_to_defensor_CE_error = 0
        total_attacker_loss = 0
        last_x_reconstructed = None

        for i, (data, targets) in enumerate(data_loader, 0):
            datav = Variable(data).to(device)
            targets = Variable(targets).to(device)

            # train attacker
            x_reconstructed, mean, logvar, p, q = attacker.run_step(datav) # p, q are sampled from mean,logvar distribution
            last_x_reconstructed = x_reconstructed

            reconstruction_loss = attacker.reconstruction_loss(x_reconstructed, datav)
            kl_divergence_loss = attacker.kl_divergence_loss(p, q)
            vae_loss = reconstruction_loss + kl_divergence_loss
            total_vae_loss += vae_loss

            defensor_with_generated_input = defensor(x_reconstructed)
            attacker_output_to_defensor_CE_error = criterion(
                torch.tensor(defensor_with_generated_input), targets) * attack_defensor_loss_weight
            total_attacker_output_to_defensor_CE_error += attacker_output_to_defensor_CE_error

            attacker_loss = vae_loss - total_attacker_output_to_defensor_CE_error
            total_attacker_loss += attacker_loss

            optim_gen.zero_grad()
            attacker_loss.backward()
            optim_gen.step()

            # tensorboard log
            writer.add_scalar("Loss/Minibatches_reconstruction_loss", reconstruction_loss, (i+1)*epoch)
            writer.add_scalar("Loss/Minibatches_kl_divergence_loss", kl_divergence_loss, (i+1)*epoch)
            writer.add_scalar("Loss/Minibatches_attacker_output_to_defensor_CE_error", 
                attacker_output_to_defensor_CE_error, (i+1)*epoch)
            writer.add_scalar("Loss/Minibatches_attacker_loss", attacker_loss, (i+1)*epoch)

        writer.add_scalar("Loss/Epochs_total_vae_loss", total_vae_loss, epoch)
        writer.add_scalar("Loss/Epochs_total_attacker_output_to_defensor_CE_error", 
            total_attacker_output_to_defensor_CE_error, epoch)
        writer.add_scalar("Loss/Epochs_total_attacker_loss", total_attacker_loss, epoch)

        grid = torchvision.utils.make_grid(last_x_reconstructed)
        writer.add_image('Generated adversarial training example', grid, epoch)

        utils.save_checkpoint(attacker, checkpoint_dir, epoch, 'attacker')


if __name__ == "__main__":
    main()

    